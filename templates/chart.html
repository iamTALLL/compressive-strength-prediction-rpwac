{% extends "base.html" %}
{% block title %}Prediction Logs{% endblock %}

{% block content %}
<div class="container mt-4">
  <div class="card shadow-sm p-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h3 class="mb-0">Prediction Logs</h3>
      <small class="text-muted">Select a log to view</small>
    </div>

    <!-- Dropdown chọn log -->
    <div class="mb-3">
      <select id="logSelect" class="form-select">
        <option value="" disabled selected>-- Select a log file --</option>
        {% for file in logs %}
        <option value="{{ file }}">{{ file }}</option>
        {% endfor %}
      </select>
    </div>

    <!-- Upload area (hiện khi chưa có y_true hoặc để replace) -->
    <div id="uploadSection" class="mb-3" style="display:none;">
      <div class="alert alert-info py-2 mb-2" id="uploadMessage">
        <!-- dynamic message -->
      </div>
      <form id="uploadForm" class="d-flex gap-2 align-items-center" enctype="multipart/form-data">
        <input type="file" name="reality_csv" accept=".csv" class="form-control form-control-sm" required>
        <button type="submit" class="btn btn-sm btn-primary">Upload y_true CSV</button>
        <div id="uploadStatus" class="ms-2"></div>
      </form>
    </div>

    <!-- Chart area -->
    <div id="chartWrapper" style="min-height:280px;">
      <canvas id="predictionChart" style="max-height:520px;"></canvas>
      <div id="noDataNotice" class="text-muted mt-2" style="display:none;">
        <em>No actual values (y_true) found. Upload y_true CSV to see Predicted vs Actual scatter plot.</em>
      </div>
    </div>
  </div>
</div>

<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
(function(){
  const logSelect = document.getElementById('logSelect');
  const uploadSection = document.getElementById('uploadSection');
  const uploadForm = document.getElementById('uploadForm');
  const uploadMessage = document.getElementById('uploadMessage');
  const uploadStatus = document.getElementById('uploadStatus');
  const chartCanvas = document.getElementById('predictionChart');
  const noDataNotice = document.getElementById('noDataNotice');

  let currentFile = null;
  let predChart = null;

  function safeEncode(s){
    return encodeURIComponent(s).replace(/%20/g, '+');
  }

  async function fetchChartData(filename){
    try {
      const resp = await fetch(`/chart_data/${safeEncode(filename)}`);
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Server returned ${resp.status}: ${txt}`);
      }
      const data = await resp.json();
      return data;
    } catch (err) {
      console.error('fetchChartData error', err);
      throw err;
    }
  }

  function hasYTrue(data){
    if (!Array.isArray(data) || data.length === 0) return false;
    // check if any row has a non-null, non-empty y_true
    return data.some(r => r.y_true !== undefined && r.y_true !== null && String(r.y_true).trim() !== '');
  }

  function clearChart(){
    if (predChart) {
      try { predChart.destroy(); } catch(e) {}
      predChart = null;
    }
  }

  function renderScatter(predicted, actual){
    clearChart();

    // compute min/max across both arrays
    const all = predicted.concat(actual.filter(v => v !== null && v !== undefined));
    const numeric = all.filter(v => typeof v === 'number' && !isNaN(v));
    const minVal = numeric.length ? Math.min(...numeric) : 0;
    const maxVal = numeric.length ? Math.max(...numeric) : 1;

    const scatterPoints = predicted.map((x, i) => ({ x: x, y: actual[i] }));

    const ctx = chartCanvas.getContext('2d');
    predChart = new Chart(ctx, {
      type: 'scatter',
      data: {
        datasets: [
          {
            label: 'Predicted vs Actual',
            data: scatterPoints,
            backgroundColor: 'rgba(0,123,255,0.85)',
            pointRadius: 5,
            showLine: false
          },
          {
            label: 'y = x',
            type: 'line',
            data: [
              { x: minVal, y: minVal },
              { x: maxVal, y: maxVal }
            ],
            borderColor: 'rgba(220,53,69,0.9)', // bootstrap danger
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            borderDash: [6,4]
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: function(context) {
                // context.raw is {x, y}
                const r = context.raw || {};
                return `Predicted: ${r.x} , Actual: ${r.y}`;
              }
            }
          }
        },
        scales: {
          x: {
            title: { display: true, text: 'Predicted (Predicted_c_cs)' }
          },
          y: {
            title: { display: true, text: 'Actual (y_true)' }
          }
        }
      }
    });
  }

  async function onSelectChange(){
    const filename = logSelect.value;
    if (!filename) return;

    currentFile = filename;
    uploadStatus.textContent = '';
    uploadSection.style.display = 'none';
    noDataNotice.style.display = 'none';
    clearChart();

    try {
      const data = await fetchChartData(filename);

      if (!Array.isArray(data) || data.length === 0) {
        uploadMessage.textContent = 'Log is empty.';
        uploadSection.style.display = 'block';
        noDataNotice.style.display = 'block';
        noDataNotice.textContent = 'Log file is empty.';
        return;
      }

      if (!hasYTrue(data)) {
        // show upload form & message
        uploadMessage.textContent = 'No actual (y_true) values found for this log. Upload y_true CSV to see the Predicted vs Actual scatter plot.';
        uploadSection.style.display = 'block';
        noDataNotice.style.display = 'block';
        noDataNotice.textContent = 'No actual values (y_true) found. Upload y_true CSV to see chart.';
        return;
      }

      // has y_true -> prepare arrays and render scatter
      const predicted = data.map(r => {
        const v = Number(r.Predicted_c_cs);
        return isNaN(v) ? null : v;
      });
      const actual = data.map(r => {
        const v = Number(r.y_true);
        return isNaN(v) ? null : v;
      });

      // hide upload message but still allow replace: show uploadSection (replace)
      uploadMessage.textContent = 'Actual values found. You may upload another y_true CSV to replace.';
      uploadSection.style.display = 'block';
      noDataNotice.style.display = 'none';

      renderScatter(predicted, actual);

    } catch (err) {
      uploadMessage.textContent = 'Error loading log. See console.';
      uploadSection.style.display = 'block';
      noDataNotice.style.display = 'block';
      noDataNotice.textContent = 'Error loading chart data.';
    }
  }

  // handle upload form submit
  uploadForm.addEventListener('submit', async function(e){
    e.preventDefault();
    if (!currentFile) {
      alert('Please select a log file first.');
      return;
    }
    const input = uploadForm.querySelector('input[type="file"]');
    if (!input.files || input.files.length === 0) {
      alert('Please choose a CSV file to upload.');
      return;
    }

    const file = input.files[0];
    const formData = new FormData();
    formData.append('reality_csv', file);

    const uploadUrl = `/upload_reality/${safeEncode(currentFile)}`;

    // UI feedback
    uploadStatus.innerHTML = '<span class="text-muted">Uploading...</span>';
    uploadForm.querySelector('button[type="submit"]').disabled = true;

    try {
      const resp = await fetch(uploadUrl, { method: 'POST', body: formData });
      const result = await resp.json();
      if (!resp.ok || !result.success) {
        const errMsg = result.error || `Upload failed (status ${resp.status})`;
        uploadStatus.innerHTML = `<span class="text-danger">${errMsg}</span>`;
        console.error('Upload error', result);
      } else {
        uploadStatus.innerHTML = `<span class="text-success">Upload successful. Rendering chart...</span>`;
        // refresh and render chart automatically
        await onSelectChange();
      }
    } catch (err) {
      console.error('Upload exception', err);
      uploadStatus.innerHTML = `<span class="text-danger">Upload error</span>`;
    } finally {
      uploadForm.querySelector('button[type="submit"]').disabled = false;
    }
  });

  // trigger when user selects a log
  logSelect.addEventListener('change', onSelectChange);

  // initial: hide everything until selected
  uploadSection.style.display = 'none';
  noDataNotice.style.display = 'none';
})();
</script>
{% endblock %}
